<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LOOM Neural Network WASM Demo</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background: #f5f5f5;
      }
      .container {
        background: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }
      h1 {
        color: #333;
        border-bottom: 3px solid #4caf50;
        padding-bottom: 10px;
      }
      h2 {
        color: #555;
        margin-top: 30px;
      }
      button {
        background: #4caf50;
        color: white;
        border: none;
        padding: 12px 24px;
        margin: 5px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.3s;
      }
      button:hover {
        background: #45a049;
      }
      button:disabled {
        background: #cccccc;
        cursor: not-allowed;
      }
      pre {
        background: #f4f4f4;
        padding: 15px;
        border-radius: 5px;
        overflow-x: auto;
        border-left: 4px solid #4caf50;
      }
      .output {
        background: #1e1e1e;
        color: #d4d4d4;
        padding: 15px;
        border-radius: 5px;
        font-family: "Courier New", monospace;
        font-size: 13px;
        max-height: 400px;
        overflow-y: auto;
        margin-top: 10px;
      }
      .success {
        color: #4caf50;
        font-weight: bold;
      }
      .error {
        color: #f44336;
        font-weight: bold;
      }
      .info {
        color: #2196f3;
      }
      input[type="number"] {
        padding: 8px;
        margin: 5px;
        border: 1px solid #ddd;
        border-radius: 4px;
        width: 100px;
      }
      label {
        margin-right: 10px;
        font-weight: 500;
      }
      .param-group {
        margin: 10px 0;
        padding: 10px;
        background: #f9f9f9;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ðŸ§  LOOM Neural Network WASM Demo</h1>
      <p>
        This demo shows how to use the LOOM neural network framework compiled to
        WebAssembly.
      </p>
      <p id="status">Loading WASM module...</p>
    </div>

    <div class="container">
      <h2>1. Create Network</h2>
      <div class="param-group">
        <label>Input Size:</label>
        <input type="number" id="inputSize" value="784" min="1" />
        <label>Grid Rows:</label>
        <input type="number" id="gridRows" value="1" min="1" />
        <label>Grid Cols:</label>
        <input type="number" id="gridCols" value="1" min="1" />
        <label>Layers Per Cell:</label>
        <input type="number" id="layersPerCell" value="2" min="1" />
      </div>
      <button onclick="createNetwork()">Create Network</button>
      <button onclick="inspectMethods()">Inspect Methods</button>
      <pre id="networkOutput"></pre>
    </div>

    <div class="container">
      <h2>2. Train Network</h2>
      <div class="param-group">
        <label>Epochs:</label>
        <input type="number" id="epochs" value="5" min="1" max="100" />
        <label>Learning Rate:</label>
        <input
          type="number"
          id="learningRate"
          value="0.01"
          min="0.001"
          max="1"
          step="0.001"
        />
        <label>Batch Size:</label>
        <input type="number" id="batchSize" value="32" min="1" />
      </div>
      <button onclick="trainNetwork()" id="trainBtn" disabled>
        Train Network
      </button>
      <button onclick="testForward()" id="forwardBtn" disabled>
        Test Forward Pass
      </button>
      <pre id="trainOutput"></pre>
    </div>

    <div class="container">
      <h2>3. Save/Load Model</h2>
      <button onclick="saveModel()" id="saveBtn" disabled>Save Model</button>
      <button onclick="loadModel()" id="loadBtn" disabled>Load Model</button>
      <pre id="modelOutput"></pre>
    </div>

    <div class="container">
      <h2>Console Output</h2>
      <div id="console" class="output">
        <div class="info">Waiting for WASM module to load...</div>
      </div>
    </div>

    <script src="wasm_exec.js"></script>
    <script>
      let network = null;
      let savedModel = null;

      function log(message, type = "info") {
        const console = document.getElementById("console");
        const timestamp = new Date().toLocaleTimeString();
        const className =
          type === "error" ? "error" : type === "success" ? "success" : "info";
        console.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
        console.scrollTop = console.scrollHeight;
      }

      function createNetwork() {
        try {
          const inputSize = parseInt(
            document.getElementById("inputSize").value
          );
          const gridRows = parseInt(document.getElementById("gridRows").value);
          const gridCols = parseInt(document.getElementById("gridCols").value);
          const layersPerCell = parseInt(
            document.getElementById("layersPerCell").value
          );

          console.log("=== Creating Network ===");
          console.log(`Input Size: ${inputSize}`);
          console.log(`Grid: ${gridRows} x ${gridCols}`);
          console.log(`Layers per cell: ${layersPerCell}`);
          console.log(`Total layers: ${gridRows * gridCols * layersPerCell}`);

          log(
            `Creating network: ${inputSize} input, ${gridRows}x${gridCols} grid, ${layersPerCell} layers/cell`
          );
          network = NewNetwork(inputSize, gridRows, gridCols, layersPerCell);

          console.log("Network object:", network);
          console.log(
            "Available methods:",
            network.ListMethods ? JSON.parse(network.ListMethods()) : "N/A"
          );

          // Initialize layers with actual weights
          const totalLayers = gridRows * gridCols * layersPerCell;
          log(`Initializing ${totalLayers} dense layers...`);

          let currentSize = inputSize;
          for (let i = 0; i < totalLayers; i++) {
            const row = Math.floor(i / (gridCols * layersPerCell));
            const remainder = i % (gridCols * layersPerCell);
            const col = Math.floor(remainder / layersPerCell);
            const layer = remainder % layersPerCell;

            const outputSize =
              i === totalLayers - 1
                ? 10
                : Math.max(32, Math.floor(currentSize / 2)); // Last layer outputs 10, others halve
            const activation = i % 5; // Cycle through activations (0=ReLU, 1=Sigmoid, 2=Tanh, 3=Softmax, 4=Linear)

            console.log(
              `  Layer ${i} (row=${row}, col=${col}, layer=${layer}): ${currentSize} â†’ ${outputSize}, activation=${activation}`
            );

            // Create layer config using global InitDenseLayer function
            const configJSON = InitDenseLayer(
              currentSize,
              outputSize,
              activation
            );
            const config = JSON.parse(configJSON);

            console.log(
              `    Config created: ${
                config.Kernel ? config.Kernel.length : 0
              } weights`
            );

            // Set the layer in the network
            const result = network.SetLayer(
              JSON.stringify([row, col, layer, config])
            );
            console.log(`    SetLayer result: ${result}`);

            currentSize = outputSize;
          }

          document.getElementById("networkOutput").textContent =
            `âœ“ Network created successfully!\n` +
            `  Input Size: ${inputSize}\n` +
            `  Grid: ${gridRows} rows x ${gridCols} cols\n` +
            `  Layers per cell: ${layersPerCell}\n` +
            `  Total layers: ${totalLayers}\n` +
            `  Output size: ${currentSize}\n\n` +
            `  Network details logged to browser console`;

          log(
            `Network created with ${totalLayers} initialized layers!`,
            "success"
          );

          // Enable other buttons
          document.getElementById("trainBtn").disabled = false;
          document.getElementById("forwardBtn").disabled = false;
          document.getElementById("saveBtn").disabled = false;
          document.getElementById("loadBtn").disabled = false;
        } catch (error) {
          console.error("Network creation error:", error);
          log(`Error creating network: ${error}`, "error");
          document.getElementById(
            "networkOutput"
          ).textContent = `Error: ${error}`;
        }
      }

      function inspectMethods() {
        if (!network) {
          log("Please create a network first", "error");
          return;
        }

        try {
          const methodsJSON = network.GetMethods();
          const methods = JSON.parse(methodsJSON);

          console.log("=== Network Introspection ===");
          console.log("Total methods:", methods.length);
          console.log("Methods detail:", methods);

          let output = "=== Available Methods ===\n\n";
          methods.forEach((method) => {
            output += `${method.method_name}\n`;
            if (method.parameters && method.parameters.length > 0) {
              output += "  Parameters:\n";
              method.parameters.forEach((param) => {
                output += `    - ${param.name}: ${param.type}\n`;
              });
            } else {
              output += "  Parameters: none\n";
            }
            if (method.returns && method.returns.length > 0) {
              output += "  Returns: " + method.returns.join(", ") + "\n";
            } else {
              output += "  Returns: void\n";
            }
            output += "\n";
          });

          output += "\nFull method details logged to browser console";

          document.getElementById("networkOutput").textContent = output;
          log(`Found ${methods.length} methods`, "success");
        } catch (error) {
          console.error("Introspection error:", error);
          log(`Error inspecting methods: ${error}`, "error");
        }
      }

      function testForward() {
        if (!network) {
          log("Please create a network first", "error");
          return;
        }

        try {
          const inputSize = parseInt(
            document.getElementById("inputSize").value
          );

          // Create random input data
          const input = new Array(inputSize).fill(0).map(() => Math.random());
          const inputJSON = JSON.stringify([input]);

          // Log input details
          console.log("=== Forward Pass Input ===");
          console.log("Input size:", inputSize);
          console.log("Input (first 10):", input.slice(0, 10));
          console.log("Input range:", [Math.min(...input), Math.max(...input)]);

          log("Running forward pass...");
          const resultStr = network.ForwardCPU(inputJSON);
          const result = JSON.parse(resultStr);

          const output = result[0]; // First element is the output array

          // Log full output details to console
          console.log("=== Forward Pass Output ===");
          console.log("Output size:", output.length);
          console.log("Full output:", output);
          console.log("Output range:", [
            Math.min(...output),
            Math.max(...output),
          ]);
          console.log("Output statistics:");
          console.log(
            "  Mean:",
            output.reduce((a, b) => a + b, 0) / output.length
          );
          console.log(
            "  Std:",
            Math.sqrt(
              output.reduce(
                (sum, val) =>
                  sum +
                  Math.pow(
                    val - output.reduce((a, b) => a + b, 0) / output.length,
                    2
                  ),
                0
              ) / output.length
            )
          );

          const outputText =
            `âœ“ Forward pass completed!\n` +
            `  Input size: ${inputSize}\n` +
            `  Output size: ${output.length}\n` +
            `  First 10 outputs: [${output
              .slice(0, 10)
              .map((v) => v.toFixed(4))
              .join(", ")}]\n` +
            `  Output range: [${Math.min(...output).toFixed(4)}, ${Math.max(
              ...output
            ).toFixed(4)}]\n` +
            `  Mean: ${(
              output.reduce((a, b) => a + b, 0) / output.length
            ).toFixed(4)}\n` +
            `  Full output logged to browser console`;

          document.getElementById("trainOutput").textContent = outputText;

          log(
            `Forward pass successful! Output size: ${
              output.length
            }, range: [${Math.min(...output).toFixed(4)}, ${Math.max(
              ...output
            ).toFixed(4)}]`,
            "success"
          );
        } catch (error) {
          console.error("Forward pass error:", error);
          log(`Error in forward pass: ${error}`, "error");
          document.getElementById(
            "trainOutput"
          ).textContent = `Error: ${error}`;
        }
      }

      function trainNetwork() {
        if (!network) {
          log("Please create a network first", "error");
          return;
        }

        try {
          log("Starting manual training demo (CPU-only in WASM)...", "info");

          const inputSize = parseInt(
            document.getElementById("inputSize").value
          );
          const numEpochs = 5;
          const batchSize = 10;

          console.log("=== Training Demo ===");
          console.log(
            `Epochs: ${numEpochs}, Batch size: ${batchSize}, Input size: ${inputSize}`
          );

          let trainingLog = "Training Progress:\n\n";

          for (let epoch = 0; epoch < numEpochs; epoch++) {
            const input = new Array(inputSize).fill(0).map(() => Math.random());
            const inputJSON = JSON.stringify([input]);

            // Forward pass
            const resultStr = network.ForwardCPU(inputJSON);
            const result = JSON.parse(resultStr);
            const output = result[0];

            // Compute dummy loss (MSE against zero target)
            const loss =
              output.reduce((sum, val) => sum + val * val, 0) / output.length;

            console.log(`Epoch ${epoch + 1}/${numEpochs}:`);
            console.log("  Input (first 5):", input.slice(0, 5));
            console.log("  Output (first 5):", output.slice(0, 5));
            console.log("  Loss:", loss);
            console.log("  Output range:", [
              Math.min(...output),
              Math.max(...output),
            ]);

            trainingLog += `Epoch ${
              epoch + 1
            }/${numEpochs}: Loss = ${loss.toFixed(6)}, `;
            trainingLog += `Output range = [${Math.min(...output).toFixed(
              4
            )}, ${Math.max(...output).toFixed(4)}]\n`;

            log(
              `Epoch ${epoch + 1}/${numEpochs}: Loss = ${loss.toFixed(6)}`,
              "info"
            );

            // In a real training loop, you would:
            // 1. Compute gradients from loss
            // 2. Call BackwardCPU with gradients
            // 3. Update weights
          }

          trainingLog +=
            "\nNote: This is a demo showing forward passes only.\n";
          trainingLog += "For full training:\n";
          trainingLog += "  1. Call ForwardCPU to get predictions\n";
          trainingLog += "  2. Compute loss in JavaScript\n";
          trainingLog += "  3. Compute gradients (âˆ‚loss/âˆ‚output)\n";
          trainingLog += "  4. Call BackwardCPU with gradients\n";
          trainingLog += "  5. Repeat for multiple epochs\n\n";
          trainingLog += "Full training details logged to browser console.";

          document.getElementById("trainOutput").textContent = trainingLog;
          console.log("=== Training Demo Complete ===");

          log(`Training demo complete! Ran ${numEpochs} epochs`, "success");
        } catch (error) {
          console.error("Training error:", error);
          log(`Error in training: ${error}`, "error");
        }
      }

      function saveModel() {
        if (!network) {
          log("Please create a network first", "error");
          return;
        }

        try {
          log("Saving model to string...");
          const modelJSON = network.SaveModelToString(
            JSON.stringify(["my_wasm_model"])
          );
          savedModel = JSON.parse(JSON.parse(modelJSON)[0]); // Unwrap the result

          console.log("=== Model Saved ===");
          console.log("Model structure:", savedModel);
          console.log("JSON size:", JSON.stringify(savedModel).length, "bytes");
          if (savedModel.layers) {
            console.log("Number of layers:", savedModel.layers.length);
            savedModel.layers.forEach((layer, i) => {
              console.log(`  Layer ${i}:`, layer.type || "unknown type");
            });
          }

          document.getElementById("modelOutput").textContent =
            `âœ“ Model saved!\n` +
            `  Model ID: my_wasm_model\n` +
            `  JSON size: ${JSON.stringify(savedModel).length} bytes\n` +
            `  Layers: ${
              savedModel.layers ? savedModel.layers.length : "N/A"
            }\n` +
            `  Preview: ${JSON.stringify(savedModel).substring(
              0,
              200
            )}...\n\n` +
            `  Full model structure logged to browser console`;

          log(
            `Model saved successfully! Size: ${
              JSON.stringify(savedModel).length
            } bytes`,
            "success"
          );
        } catch (error) {
          console.error("Save model error:", error);
          log(`Error saving model: ${error}`, "error");
          document.getElementById(
            "modelOutput"
          ).textContent = `Error: ${error}`;
        }
      }

      function loadModel() {
        if (!savedModel) {
          log("Please save a model first", "error");
          return;
        }

        try {
          log("Loading model from string...");

          console.log("=== Loading Model ===");
          console.log("Model to load:", savedModel);

          const modelStr = JSON.stringify(savedModel);

          // LoadModelFromString is a global function, not a network method
          // It returns a new network object
          network = LoadModelFromString(modelStr, "my_wasm_model");

          console.log("Loaded network:", network);

          document.getElementById("modelOutput").textContent =
            `âœ“ Model loaded!\n` +
            `  Restored from JSON (${modelStr.length} bytes)\n` +
            `  New network object created\n` +
            `  You can now use the loaded weights for inference\n\n` +
            `  Load details logged to browser console`;

          log(
            "Model loaded successfully! New network created from saved state.",
            "success"
          );
        } catch (error) {
          console.error("Load model error:", error);
          log(`Error loading model: ${error}`, "error");
          document.getElementById(
            "modelOutput"
          ).textContent = `Error: ${error}`;
        }
      }

      // Load the WASM module
      const go = new Go();
      WebAssembly.instantiateStreaming(fetch("loom.wasm"), go.importObject)
        .then((result) => {
          go.run(result.instance);
          document.getElementById("status").innerHTML =
            '<span class="success">âœ“ WASM module loaded successfully!</span>';
          log("LOOM WASM module initialized!", "success");
          log("Ready to create neural networks in the browser!", "success");
        })
        .catch((err) => {
          document.getElementById("status").innerHTML =
            '<span class="error">âœ— Failed to load WASM module: ' +
            err +
            "</span>";
          log("Failed to load WASM module: " + err, "error");
        });
    </script>
  </body>
</html>
