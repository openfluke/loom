<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LOOM WASM Optimizer Demo</title>
  <style>
    body {font-family: 'Segoe UI', Arial, sans-serif; background: #1e1e1e; color: #d4d4d4; padding: 20px; margin: 0;}
    .container {max-width: 1000px; margin: auto; background: #252526; padding: 30px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.5);}
    h1 {text-align: center; color: #569cd6; margin-top: 0;}
    h2 {color: #4ec9b0; border-bottom: 2px solid #333; padding-bottom: 8px;}
    .section {margin-top: 20px; padding: 20px; background: #1e1e1e; border: 1px solid #333; border-radius: 6px;}
    textarea {width: 100%; padding: 10px; margin-top: 8px; background: #1e1e1e; color: #d4d4d4; border: 1px solid #555; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 13px;}
    label {display: block; margin-top: 12px; color: #9cdcfe; font-weight: 500;}
    input, select {width: 100%; padding: 8px; margin-top: 4px; background: #1e1e1e; color: #d4d4d4; border: 1px solid #555; border-radius: 4px;}
    button {margin-top: 12px; margin-right: 8px; padding: 10px 16px; background: #0e639c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;}
    button:hover {background: #1177bb;}
    button:disabled {background: #444; cursor: not-allowed;}
    .output {margin-top: 15px; background: #1e1e1e; color: #d4d4d4; padding: 15px; height: 300px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 12px; border: 1px solid #333; border-radius: 4px;}
    .info {color: #4ec9b0;}
    .success {color: #4ec9b0;}
    .error {color: #f48771;}
    .training {color: #ce9178;}
    .stats {display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 15px;}
    .stat-box {background: #1e1e1e; padding: 15px; border-radius: 4px; text-align: center; border: 1px solid #333;}
    .stat-value {font-size: 24px; font-weight: bold; color: #569cd6;}
    .stat-label {font-size: 12px; color: #888; margin-top: 5px; text-transform: uppercase;}
    .test-controls {display: flex; gap: 10px; flex-wrap: wrap;}
  </style>
</head>
<body>
<div class="container">
  <h1>üöÄ LOOM WASM Optimizer Demo</h1>
  
  <div class="section">
    <h2>üìã Network Configuration</h2>
    <textarea id="jsonConfig" rows="10">{
  "batch_size": 1,
  "grid_rows": 1,
  "grid_cols": 1,
  "layers_per_cell": 3,
  "layers": [
    {"type": "dense", "input_height": 4, "output_height": 8, "activation": "relu"},
    {"type": "lstm", "input_size": 8, "hidden_size": 12, "seq_length": 1},
    {"type": "dense", "input_height": 12, "output_height": 3, "activation": "softmax"}
  ]
}</textarea>
    <button onclick="initNetwork()">üîß Initialize Network</button>
  </div>

  <div class="section" id="test-section" style="display:none;">
    <h2>üß™ Run Optimizer Tests</h2>
    <div class="test-controls">
      <button onclick="testSGD()">Test SGD</button>
      <button onclick="testAdamW()">Test AdamW</button>
      <button onclick="testRMSprop()">Test RMSprop</button>
      <button onclick="testSGDMomentum()">Test SGD+Momentum</button>
      <button onclick="runAllTests()">Run All Tests</button>
    </div>
    
    <div class="stats">
      <div class="stat-box">
        <div id="steps" class="stat-value">0</div>
        <div class="stat-label">Steps</div>
      </div>
      <div class="stat-box">
        <div id="loss" class="stat-value">0.000</div>
        <div class="stat-label">Avg Loss</div>
      </div>
      <div class="stat-box">
        <div id="optimizer" class="stat-value">-</div>
        <div class="stat-label">Optimizer</div>
      </div>
      <div class="stat-box">
        <div id="speed" class="stat-value">0</div>
        <div class="stat-label">Steps/sec</div>
      </div>
    </div>
  </div>

  <div class="output" id="log"></div>
</div>

<script src="wasm_exec.js"></script>
<script>
const go = new Go();
let network = null;
let state = null;

// Training data (matches C# test)
const trainingData = [
  {input: [0.1, 0.2, 0.1, 0.3], target: [1.0, 0.0, 0.0]},
  {input: [0.8, 0.9, 0.7, 0.8], target: [0.0, 1.0, 0.0]},
  {input: [0.3, 0.5, 0.9, 0.6], target: [0.0, 0.0, 1.0]},
  {input: [0.2, 0.1, 0.2, 0.2], target: [1.0, 0.0, 0.0]},
  {input: [0.9, 0.8, 0.8, 0.9], target: [0.0, 1.0, 0.0]},
  {input: [0.4, 0.6, 0.8, 0.7], target: [0.0, 0.0, 1.0]}
];

function log(msg, type='info') {
  const out = document.getElementById('log');
  const time = new Date().toLocaleTimeString();
  const className = type;
  out.innerHTML += `<div class="${className}">[${time}] ${msg}</div>`;
  out.scrollTop = out.scrollHeight;
}

function updateStats(steps, avgLoss, optimizerName, stepsPerSec) {
  document.getElementById('steps').textContent = steps;
  document.getElementById('loss').textContent = avgLoss.toFixed(6);
  document.getElementById('optimizer').textContent = optimizerName;
  document.getElementById('speed').textContent = Math.round(stepsPerSec);
}

WebAssembly.instantiateStreaming(fetch('main.wasm'), go.importObject).then(result => {
  go.run(result.instance);
  log('‚úÖ WASM module loaded', 'success');
}).catch(err => {
  log('‚ùå Failed to load WASM: ' + err, 'error');
});

function initNetwork() {
  const cfg = document.getElementById('jsonConfig').value;
  try {
    network = createLoomNetwork(cfg);
    if (typeof network === 'string') {
      log('‚ùå Error creating network: ' + network, 'error');
      network = null;
      return;
    }
    
    state = network.createStepState(4);
    log('‚úÖ Network and step state initialized', 'success');
    document.getElementById('test-section').style.display = 'block';
  } catch(e) {
    log('‚ùå Exception: ' + e, 'error');
  }
}

async function runTrainingLoop(optimizerName, applyGradientsFn, steps = 5000) {
  if (!network || !state) {
    log('‚ùå Network not initialized', 'error');
    return;
  }

  log(`üèÉ Starting ${optimizerName} training for ${steps} steps...`, 'training');
  const startTime = performance.now();
  let totalLoss = 0.0;

  for (let step = 0; step < steps; step++) {
    const idx = step % trainingData.length;
    const {input, target} = trainingData[idx];

    // Forward pass
    state.setInput(new Float32Array(input));
    state.stepForward();
    const output = state.getOutput();

    // Calculate loss and gradients
    let loss = 0.0;
    const gradients = new Float32Array(3);
    for (let i = 0; i < 3; i++) {
      const diff = output[i] - target[i];
      loss += diff * diff;
      gradients[i] = 2.0 * diff / 3.0;
    }
    loss /= 3.0;
    totalLoss += loss;

    // Backward pass
    state.stepBackward(gradients);

    // Apply optimizer
    applyGradientsFn();

    // Log every 1000 steps
    if ((step + 1) % 1000 === 0) {
      const avgLoss = totalLoss / 1000;
      const elapsed = (performance.now() - startTime) / 1000;
      const stepsPerSec = (step + 1) / elapsed;
      updateStats(step + 1, avgLoss, optimizerName, stepsPerSec);
      log(`  Step ${step + 1}: Avg Loss=${avgLoss.toFixed(6)}`, 'info');
      totalLoss = 0.0;
      
      // Yield to browser
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }

  const totalTime = (performance.now() - startTime) / 1000;
  const finalStepsPerSec = steps / totalTime;
  log(`‚úÖ ${optimizerName} complete! Time: ${totalTime.toFixed(2)}s (${Math.round(finalStepsPerSec)} steps/sec)`, 'success');
}

// Test SGD
async function testSGD() {
  // Reinitialize network
  initNetwork();
  await new Promise(resolve => setTimeout(resolve, 100));
  
  await runTrainingLoop('SGD', () => {
    // Call LoomApplyGradients via reflection
    try {
      const result = network.ApplyGradients(JSON.stringify([0.01]));
      // Check for errors
      if (typeof result === 'string' && result.includes('error')) {
        log('‚ùå SGD Error: ' + result, 'error');
      }
    } catch(e) {
      log('‚ùå SGD Exception: ' + e, 'error');
    }
  });
}

// Test AdamW
async function testAdamW() {
  // Reinitialize network
  initNetwork();
  await new Promise(resolve => setTimeout(resolve, 100));
  
  await runTrainingLoop('AdamW', () => {
    try {
      const result = network.ApplyGradientsAdamW(JSON.stringify([0.001, 0.9, 0.999, 0.01]));
      if (typeof result === 'string' && result.includes('error')) {
        log('‚ùå AdamW Error: ' + result, 'error');
      }
    } catch(e) {
      log('‚ùå AdamW Exception: ' + e, 'error');
    }
  });
}

// Test RMSprop
async function testRMSprop() {
  // Reinitialize network
  initNetwork();
  await new Promise(resolve => setTimeout(resolve, 100));
  
  await runTrainingLoop('RMSprop', () => {
    try {
      const result = network.ApplyGradientsRMSprop(JSON.stringify([0.001, 0.99, 1e-8, 0.0]));
      if (typeof result === 'string' && result.includes('error')) {
        log('‚ùå RMSprop Error: ' + result, 'error');
      }
    } catch(e) {
      log('‚ùå RMSprop Exception: ' + e, 'error');
    }
  });
}

// Test SGD with Momentum
async function testSGDMomentum() {
  // Reinitialize network
  initNetwork();
  await new Promise(resolve => setTimeout(resolve, 100));
  
  await runTrainingLoop('SGD+Momentum', () => {
    try {
      const result = network.ApplyGradientsSGDMomentum(JSON.stringify([0.01, 0.9, 0.0, 0]));
      if (typeof result === 'string' && result.includes('error')) {
        log('‚ùå SGD+Momentum Error: ' + result, 'error');
      }
    } catch(e) {
      log('‚ùå SGD+Momentum Exception: ' + e, 'error');
    }
  });
}

// Run all tests sequentially
async function runAllTests() {
  log('üéØ Starting all optimizer tests...', 'success');
  await testSGD();
  await new Promise(resolve => setTimeout(resolve, 500));
  await testAdamW();
  await new Promise(resolve => setTimeout(resolve, 500));
  await testRMSprop();
  await new Promise(resolve => setTimeout(resolve, 500));
  await testSGDMomentum();
  log('üéâ All tests complete!', 'success');
}
</script>
</body>
</html>