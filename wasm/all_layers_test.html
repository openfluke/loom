<!DOCTYPE html>
<!--
  LOOM All Layers Test (WebAssembly)
  
  ‚ú® ONE FUNCTION CALL TO RULE THEM ALL! ‚ú®
  
  This demonstrates LoadModelFromString() which takes a JSON string
  and returns a fully configured network with ALL weights loaded.
  
  No manual layer setup, no type conversions, no hassle!
  Just: network = LoadModelFromString(jsonString, modelID)
  
  The test:
  1. Fetches model.json from localhost:3123
  2. Calls LoadModelFromString() - DONE! Network ready!
  3. Runs inference and compares with expected outputs
  4. Trains the network to verify weights are mutable
-->
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LOOM - All Layers Test (WASM)</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background: #1a1a1a;
        color: #e0e0e0;
      }
      h1 {
        color: #4fc3f7;
        border-bottom: 2px solid #4fc3f7;
        padding-bottom: 10px;
      }
      h2 {
        color: #81c784;
        margin-top: 30px;
      }
      .section {
        background: #2d2d2d;
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0;
        border: 1px solid #3d3d3d;
      }
      .status {
        padding: 10px;
        margin: 10px 0;
        border-radius: 4px;
        font-family: "Courier New", monospace;
      }
      .status.loading {
        background: #1e3a5f;
        border-left: 4px solid #4fc3f7;
      }
      .status.success {
        background: #1b5e20;
        border-left: 4px solid #81c784;
      }
      .status.error {
        background: #5f1e1e;
        border-left: 4px solid #ef5350;
      }
      .status.info {
        background: #3d3d3d;
        border-left: 4px solid #ffa726;
      }
      button {
        background: #4fc3f7;
        color: #000;
        border: none;
        padding: 12px 24px;
        font-size: 16px;
        border-radius: 4px;
        cursor: pointer;
        margin: 5px;
        font-weight: bold;
      }
      button:hover {
        background: #29b6f6;
      }
      button:disabled {
        background: #555;
        color: #888;
        cursor: not-allowed;
      }
      .output-box {
        background: #1a1a1a;
        border: 1px solid #3d3d3d;
        border-radius: 4px;
        padding: 15px;
        margin: 10px 0;
        font-family: "Courier New", monospace;
        white-space: pre-wrap;
        max-height: 300px;
        overflow-y: auto;
      }
      .comparison {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin: 20px 0;
      }
      .comparison > div {
        background: #1a1a1a;
        padding: 15px;
        border-radius: 4px;
        border: 1px solid #3d3d3d;
      }
      .value {
        color: #4fc3f7;
        font-weight: bold;
      }
      .label {
        color: #aaa;
        font-size: 0.9em;
      }
      .controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin: 15px 0;
      }
    </style>
  </head>
  <body>
    <h1>üß† LOOM All Layers Test (WebAssembly)</h1>

    <div class="section">
      <h2>üì• Step 1: Load Files from Server</h2>
      <p class="label">
        Server URL: <span class="value">http://localhost:3123</span>
      </p>
      <div class="controls">
        <button id="loadFilesBtn" onclick="loadAllFiles()">
          Load Model + Inputs/Outputs
        </button>
        <button id="generateDataBtn" onclick="generateTestData()">
          üé≤ Generate Random Test Data
        </button>
      </div>
      <div id="loadStatus"></div>
    </div>

    <div class="section">
      <h2>üîÑ Step 2: Load or Create Model in WASM</h2>
      <p class="label">
        Choose to load a pre-trained model from file, or create a fresh network
        from JSON config
      </p>
      <div class="controls">
        <button id="loadModelBtn" onclick="loadModelInWASM()" disabled>
          üì• Load Pre-trained Model
        </button>
        <button id="createModelBtn" onclick="createModelFromJSON()">
          ‚ú® Create New Model from JSON
        </button>
      </div>
      <div id="modelStatus"></div>
    </div>

    <div class="section">
      <h2>‚ñ∂Ô∏è Step 3: Run Inference</h2>
      <div class="controls">
        <button id="runInferenceBtn" onclick="runInference()" disabled>
          Run Forward Pass
        </button>
      </div>
      <div id="inferenceStatus"></div>
      <div class="comparison" id="outputComparison" style="display: none">
        <div>
          <h3>Expected Output (from file)</h3>
          <div class="output-box" id="expectedOutput"></div>
        </div>
        <div>
          <h3>WASM Output (computed)</h3>
          <div class="output-box" id="wasmOutput"></div>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>üéØ Step 4: Train Model</h2>
      <div class="controls">
        <button id="trainBtn" onclick="trainModel()" disabled>
          Train (10 epochs)
        </button>
      </div>
      <div id="trainStatus"></div>
      <div id="trainResults" style="display: none">
        <h3>Training Results</h3>
        <div class="output-box" id="trainOutput"></div>
      </div>
    </div>

    <script src="wasm_exec.js"></script>
    <script>
      // Global state
      let modelJSON = null;
      let inputsData = null;
      let outputsData = null;
      let wasmReady = false;
      let modelLoaded = false;
      let modelID = "all_layers_test";
      let network = null; // Store the network object

      // Load WASM
      const go = new Go();
      WebAssembly.instantiateStreaming(fetch("loom.wasm"), go.importObject)
        .then((result) => {
          go.run(result.instance);
          wasmReady = true;
          log("loadStatus", "‚úÖ WASM loaded and ready", "success");
        })
        .catch((err) => {
          log("loadStatus", "‚ùå Failed to load WASM: " + err, "error");
        });

      function log(elementId, message, type = "info") {
        const element = document.getElementById(elementId);
        const div = document.createElement("div");
        div.className = `status ${type}`;
        div.textContent = message;
        element.appendChild(div);
        console.log(`[${type}] ${message}`);
      }

      function clearLog(elementId) {
        document.getElementById(elementId).innerHTML = "";
      }

      async function loadAllFiles() {
        clearLog("loadStatus");
        log(
          "loadStatus",
          "üì° Fetching files from localhost:3123...",
          "loading"
        );

        const btn = document.getElementById("loadFilesBtn");
        btn.disabled = true;

        try {
          // Load model JSON
          log("loadStatus", "Loading test.json...", "loading");
          const modelResponse = await fetch("http://localhost:3123/test.json");
          if (!modelResponse.ok) throw new Error("Failed to fetch test.json");
          modelJSON = await modelResponse.text();
          log(
            "loadStatus",
            `‚úÖ test.json loaded (${(modelJSON.length / 1024).toFixed(1)} KB)`,
            "success"
          );

          // Load inputs
          log("loadStatus", "Loading inputs.txt...", "loading");
          const inputsResponse = await fetch(
            "http://localhost:3123/inputs.txt"
          );
          if (!inputsResponse.ok) throw new Error("Failed to fetch inputs.txt");
          const inputsText = await inputsResponse.text();
          inputsData = inputsText
            .trim()
            .split("\n")
            .map((v) => parseFloat(v));
          log(
            "loadStatus",
            `‚úÖ inputs.txt loaded (${inputsData.length} values)`,
            "success"
          );

          // Load outputs
          log("loadStatus", "Loading outputs.txt...", "loading");
          const outputsResponse = await fetch(
            "http://localhost:3123/outputs.txt"
          );
          if (!outputsResponse.ok)
            throw new Error("Failed to fetch outputs.txt");
          const outputsText = await outputsResponse.text();
          outputsData = outputsText
            .trim()
            .split("\n")
            .map((v) => parseFloat(v));
          log(
            "loadStatus",
            `‚úÖ outputs.txt loaded (${outputsData.length} values)`,
            "success"
          );

          // Display expected output
          document.getElementById("expectedOutput").textContent = outputsData
            .map((v, i) => `[${i}] ${v.toFixed(6)}`)
            .join("\n");

          // Enable next step
          document.getElementById("loadModelBtn").disabled = false;
          log("loadStatus", "üéâ All files loaded successfully!", "success");
        } catch (error) {
          log(
            "loadStatus",
            "‚ùå Error loading files: " + error.message,
            "error"
          );
          log(
            "loadStatus",
            "‚ö†Ô∏è Make sure the server is running: cd examples && ./serve_files.sh",
            "error"
          );
          btn.disabled = false;
        }
      }

      function generateTestData() {
        clearLog("loadStatus");
        log("loadStatus", "üé≤ Generating random test data...", "loading");

        const btn = document.getElementById("generateDataBtn");
        btn.disabled = true;

        try {
          // Generate random input data (32 values as expected by the network)
          inputsData = new Array(32);
          for (let i = 0; i < 32; i++) {
            inputsData[i] = Math.random();
          }

          log(
            "loadStatus",
            `‚úÖ Generated ${inputsData.length} random input values`,
            "success"
          );

          // Generate expected output (2 values for the softmax output)
          // Just random values for comparison purposes
          outputsData = [Math.random(), Math.random()];

          // Normalize to sum to 1 (like softmax)
          const sum = outputsData[0] + outputsData[1];
          outputsData[0] /= sum;
          outputsData[1] /= sum;

          log(
            "loadStatus",
            `‚úÖ Generated ${outputsData.length} random output values`,
            "success"
          );

          // Display expected output
          document.getElementById("expectedOutput").textContent = outputsData
            .map((v, i) => `[${i}] ${v.toFixed(6)}`)
            .join("\n");

          // Enable next step (for loading pre-trained model)
          document.getElementById("loadModelBtn").disabled = false;

          log("loadStatus", "üéâ Test data generated successfully!", "success");
          log(
            "loadStatus",
            "   You can now create a model or load one from file",
            "info"
          );
        } catch (error) {
          log(
            "loadStatus",
            "‚ùå Error generating data: " + error.message,
            "error"
          );
          btn.disabled = false;
        }
      }

      function loadModelInWASM() {
        clearLog("modelStatus");

        if (!wasmReady) {
          log("modelStatus", "‚ùå WASM not ready yet", "error");
          return;
        }

        if (!modelJSON) {
          log("modelStatus", "‚ùå No model JSON loaded", "error");
          return;
        }

        const btn = document.getElementById("loadModelBtn");
        btn.disabled = true;

        try {
          log(
            "modelStatus",
            "üîÑ Loading pre-trained model into WASM...",
            "loading"
          );

          // Call WASM function to load model
          network = window.LoadModelFromString(modelJSON, modelID);

          if (network) {
            modelLoaded = true;
            log(
              "modelStatus",
              "‚úÖ Pre-trained model loaded in WASM successfully!",
              "success"
            );
            log("modelStatus", `   Model ID: ${modelID}`, "info");

            // Enable inference
            document.getElementById("runInferenceBtn").disabled = false;
            document.getElementById("trainBtn").disabled = false;
          } else {
            throw new Error("LoadModelFromString returned null");
          }
        } catch (error) {
          log(
            "modelStatus",
            "‚ùå Error loading model: " + error.message,
            "error"
          );
          btn.disabled = false;
        }
      }

      function createModelFromJSON() {
        clearLog("modelStatus");

        if (!wasmReady) {
          log("modelStatus", "‚ùå WASM not ready yet", "error");
          return;
        }

        const btn = document.getElementById("createModelBtn");
        btn.disabled = true;

        try {
          log(
            "modelStatus",
            "üîÑ Creating new network from JSON config...",
            "loading"
          );

          // Embedded JSON configuration - all layer types
          const jsonConfig = {
            id: "all_layers_test",
            batch_size: 1,
            grid_rows: 1,
            grid_cols: 1,
            layers_per_cell: 11,
            layers: [
              {
                type: "dense",
                activation: "leaky_relu",
                input_height: 32,
                output_height: 32,
              },
              {
                type: "rms_norm",
                norm_size: 32,
                epsilon: 1e-6,
              },
              {
                type: "conv2d",
                activation: "leaky_relu",
                input_channels: 2,
                filters: 4,
                kernel_size: 3,
                stride: 2,
                padding: 1,
                input_height: 4,
                input_width: 4,
                output_height: 2,
                output_width: 2,
              },
              {
                type: "multi_head_attention",
                activation: "relu",
                d_model: 4,
                num_heads: 2,
                seq_length: 4,
              },
              {
                type: "dense",
                activation: "sigmoid",
                input_height: 16,
                output_height: 16,
              },
              {
                type: "rnn",
                activation: "tanh",
                input_size: 4,
                hidden_size: 4,
                seq_length: 4,
              },
              {
                type: "lstm",
                activation: "tanh",
                input_size: 4,
                hidden_size: 4,
                seq_length: 4,
              },
              {
                type: "swiglu",
                input_height: 16,
                output_height: 24,
              },
              {
                type: "layer_norm",
                norm_size: 16,
                epsilon: 1e-5,
              },
              {
                type: "dense",
                activation: "sigmoid",
                input_height: 16,
                output_height: 2,
              },
              {
                type: "softmax",
                softmax_variant: "standard",
                softmax_rows: 1,
                softmax_cols: 2,
              },
            ],
          };

          const jsonConfigStr = JSON.stringify(jsonConfig);
          log(
            "modelStatus",
            `   Config size: ${(jsonConfigStr.length / 1024).toFixed(1)} KB`,
            "info"
          );
          log(
            "modelStatus",
            "   Layers: Dense ‚Üí RMSNorm ‚Üí Conv2D ‚Üí Attention ‚Üí Dense ‚Üí RNN ‚Üí LSTM ‚Üí SwiGLU ‚Üí LayerNorm ‚Üí Dense ‚Üí Softmax",
            "info"
          );

          // Call WASM function to build network from JSON
          network = window.BuildNetworkFromJSON(jsonConfigStr);

          if (network) {
            log(
              "modelStatus",
              "‚úÖ Network created from JSON successfully!",
              "success"
            );
            log(
              "modelStatus",
              "   Network structure: 1 row √ó 1 col √ó 11 layers = 11 total layers",
              "info"
            );

            // Initialize weights with random values
            log("modelStatus", "üîÑ Initializing random weights...", "loading");

            // Call WASM function to initialize weights (no parameters needed)
            const initResult = network.InitializeWeights(JSON.stringify([]));

            modelLoaded = true;
            log(
              "modelStatus",
              "‚úÖ Fresh network ready with random weights!",
              "success"
            );

            // Enable inference and training
            document.getElementById("runInferenceBtn").disabled = false;
            document.getElementById("trainBtn").disabled = false;

            log(
              "modelStatus",
              "   You can now run inference or train the model",
              "info"
            );
          } else {
            throw new Error("BuildNetworkFromJSON returned null");
          }
        } catch (error) {
          log(
            "modelStatus",
            "‚ùå Error creating model: " + error.message,
            "error"
          );
          btn.disabled = false;
        }
      }

      function runInference() {
        clearLog("inferenceStatus");

        if (!modelLoaded) {
          log("inferenceStatus", "‚ùå Model not loaded", "error");
          return;
        }

        if (!inputsData) {
          log("inferenceStatus", "‚ùå No input data loaded", "error");
          return;
        }

        const btn = document.getElementById("runInferenceBtn");
        btn.disabled = true;

        try {
          log("inferenceStatus", "üîÑ Running forward pass...", "loading");
          log("inferenceStatus", `   Input size: ${inputsData.length}`, "info");

          // Call WASM forward function on network object
          const resultJSON = network.ForwardCPU(JSON.stringify([inputsData]));
          const result = JSON.parse(resultJSON);
          const output = result[0]; // First element is the output array

          log(
            "inferenceStatus",
            `‚úÖ Forward pass complete! Output size: ${output.length}`,
            "success"
          );

          // Display WASM output
          document.getElementById("wasmOutput").textContent = output
            .map((v, i) => `[${i}] ${v.toFixed(6)}`)
            .join("\n");

          // Compare with expected
          if (outputsData && outputsData.length === output.length) {
            let maxDiff = 0;
            for (let i = 0; i < output.length; i++) {
              const diff = Math.abs(output[i] - outputsData[i]);
              if (diff > maxDiff) maxDiff = diff;
            }

            log(
              "inferenceStatus",
              `   Max difference: ${maxDiff.toFixed(10)}`,
              "info"
            );

            if (maxDiff < 1e-5) {
              log(
                "inferenceStatus",
                "‚úÖ Outputs match expected exactly!",
                "success"
              );
            } else if (maxDiff < 0.1) {
              log(
                "inferenceStatus",
                "‚úÖ Outputs match with small differences (expected with softmax)",
                "success"
              );
            } else {
              log(
                "inferenceStatus",
                "‚ö†Ô∏è Large output differences detected",
                "error"
              );
            }
          }

          document.getElementById("outputComparison").style.display = "grid";
        } catch (error) {
          log(
            "inferenceStatus",
            "‚ùå Error during inference: " + error.message,
            "error"
          );
        } finally {
          btn.disabled = false;
        }
      }

      function trainModel() {
        clearLog("trainStatus");

        if (!modelLoaded) {
          log("trainStatus", "‚ùå Model not loaded", "error");
          return;
        }

        if (!inputsData) {
          log("trainStatus", "‚ùå No input data loaded", "error");
          return;
        }

        const btn = document.getElementById("trainBtn");
        btn.disabled = true;

        try {
          log("trainStatus", "üéØ Starting training...", "loading");

          // Get output before training
          const beforeResultJSON = network.ForwardCPU(
            JSON.stringify([inputsData])
          );
          const outputBefore = JSON.parse(beforeResultJSON)[0];

          // Training config
          const config = {
            Epochs: 10,
            LearningRate: 0.05,
            UseGPU: false,
            LossType: "mse",
            Verbose: false,
          };

          // Create training batch (input -> [0.5, 0.5] target)
          const batches = [
            {
              Input: inputsData,
              Target: [0.5, 0.5],
            },
          ];

          log("trainStatus", `   Epochs: ${config.Epochs}`, "info");
          log(
            "trainStatus",
            `   Learning rate: ${config.LearningRate}`,
            "info"
          );
          log("trainStatus", "   Training...", "loading");

          // Call WASM train function
          const trainResultJSON = network.Train(
            JSON.stringify([batches, config])
          );
          const trainResult = JSON.parse(trainResultJSON);

          log("trainStatus", "‚úÖ Training complete!", "success");

          if (trainResult[0] && trainResult[0].LossHistory) {
            const result = trainResult[0];
            log(
              "trainStatus",
              `   Initial loss: ${result.LossHistory[0].toFixed(6)}`,
              "info"
            );
            log(
              "trainStatus",
              `   Final loss: ${result.FinalLoss.toFixed(6)}`,
              "info"
            );
          }

          // Get output after training
          const afterResultJSON = network.ForwardCPU(
            JSON.stringify([inputsData])
          );
          const outputAfter = JSON.parse(afterResultJSON)[0];

          // Check if weights changed
          let maxChange = 0;
          for (
            let i = 0;
            i < Math.min(outputBefore.length, outputAfter.length);
            i++
          ) {
            const change = Math.abs(outputAfter[i] - outputBefore[i]);
            if (change > maxChange) maxChange = change;
          }

          log(
            "trainStatus",
            `   Max output change: ${maxChange.toFixed(6)}`,
            "info"
          );

          if (maxChange > 1e-5) {
            log("trainStatus", "‚úÖ Weights successfully changed!", "success");
          } else {
            log("trainStatus", "‚ö†Ô∏è Weights did not change", "error");
          }

          // Display results
          document.getElementById("trainResults").style.display = "block";
          document.getElementById("trainOutput").textContent =
            `Output before training:\n${outputBefore
              .map((v, i) => `[${i}] ${v.toFixed(6)}`)
              .join("\n")}\n\n` +
            `Output after training:\n${outputAfter
              .map((v, i) => `[${i}] ${v.toFixed(6)}`)
              .join("\n")}`;
        } catch (error) {
          log(
            "trainStatus",
            "‚ùå Error during training: " + error.message,
            "error"
          );
        } finally {
          btn.disabled = false;
        }
      }
    </script>
  </body>
</html>
